// Generated by CoffeeScript 1.6.2
var File, GeneralConfiguration, Jelly, assert, async, path, toType;

assert = require('chai').assert;

async = require('async');

path = require('path');

toType = function(obj) {
  return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
};

Jelly = require('../src/Jelly');

GeneralConfiguration = require('../src/GeneralConfiguration');

File = require('../src/File');

describe('PluginInterface', function() {
  var PluginInterface;

  PluginInterface = require('../src/PluginInterface');
  it('Should be a PluginInterface', function() {
    return assert.equal(PluginInterface.prototype.PluginInterface, true);
  });
  describe('_constructor_', function() {
    return it('Should have a _constructor_', function() {
      return assert.typeOf(PluginInterface.prototype._constructor_, 'function');
    });
  });
  describe('::STATUS', function() {
    it('Should exist', function() {
      return assert.typeOf(PluginInterface.prototype.STATUS, 'object');
    });
    return it('Should contain the status', function() {
      assert.equal(PluginInterface.prototype.STATUS.NOT_LOADED, 0);
      return assert.equal(PluginInterface.prototype.STATUS.LOADED, 1);
    });
  });
  describe('#constructor', function() {
    it('creating an instance should not throw errors', function() {
      var pluginInterface;

      return pluginInterface = new PluginInterface();
    });
    it('Should extends from a Logger', function() {
      return assert.equal(PluginInterface.prototype.Logger, true);
    });
    it('Should extends from a ReadableEntity', function() {
      return assert.equal(PluginInterface.prototype.ReadableEntity, true);
    });
    return it('Should extends from a TreeElement', function() {
      return assert.equal(PluginInterface.prototype.TreeElement, true);
    });
  });
  describe('#unload', function() {
    return it('Should be a callable function', function() {
      return assert.typeOf(PluginInterface.prototype.unload, 'function');
    });
  });
  describe('#getStatus', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(PluginInterface.prototype.getStatus, 'function');
    });
    it('Should return NOT_LOADED by default', function() {
      return assert.equal(new PluginInterface().getStatus(), PluginInterface.prototype.STATUS.NOT_LOADED);
    });
    return it('Should set to LOADED if we load the plugin and NOT_LOADED if we unload the plugin', function(cb) {
      var p;

      p = new PluginInterface();
      p.updateContent({
        content: {
          load: function(cb) {
            return cb();
          },
          unload: function(cb) {
            return cb();
          }
        },
        extension: '__exec'
      });
      return p.load(function() {
        var e;

        try {
          assert.equal(p.getStatus(), PluginInterface.prototype.STATUS.LOADED);
          return p.unload(function() {
            var e;

            try {
              assert.equal(p.getStatus(), PluginInterface.prototype.STATUS.NOT_LOADED);
              cb();
              return cb = function() {};
            } catch (_error) {
              e = _error;
              return cb(e);
            }
          });
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
  });
  return describe('#oncall', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(PluginInterface.prototype.oncall, 'function');
    });
    it('Should raise an error when the caller object is invalid', function(cb) {
      var p;

      p = new PluginInterface();
      p.updateContent({
        content: {
          oncall: function(sender, params, call) {
            return call();
          }
        },
        extension: '__exec'
      });
      return p.oncall(null, {}, function(err) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    it('Should raise an error when the content is undefined', function(cb) {
      var file, p;

      p = new PluginInterface();
      file = new File();
      return p.oncall(file, {}, function(err) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    it('Should raise an error when the content is not an object', function(cb) {
      var file, p;

      p = new PluginInterface();
      file = new File();
      p.updateContent({
        content: 3,
        extension: '__exec'
      });
      return p.oncall(file, {}, function(err) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    return it('Should call the oncall method on the plugin file', function(cb) {
      var file, p;

      p = new PluginInterface();
      file = new File();
      p.updateContent({
        content: {
          oncall: function(sender, param, callback) {
            return cb();
          }
        },
        extension: '__exec'
      });
      return p.oncall(file, {}, function(err) {
        if (err != null) {
          return cb(err);
        }
      });
    });
  });
});
