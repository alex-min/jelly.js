// Generated by CoffeeScript 1.6.2
var File, GeneralConfiguration, Jelly, Logger, Module, PluginHandler, TreeElement, assert, async, path, toType;

assert = require('chai').assert;

async = require('async');

path = require('path');

toType = function(obj) {
  return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
};

Jelly = require('../src/Jelly');

Logger = require('../src/Logger');

TreeElement = require('../src/TreeElement');

GeneralConfiguration = require('../src/GeneralConfiguration');

Module = require('../src/Module');

File = require('../src/File');

PluginHandler = require('../src/PluginHandler');

describe('PluginDirectory', function() {
  var PluginDirectory;

  PluginDirectory = require('../src/PluginDirectory');
  it('Should be a PluginDirectory', function() {
    return assert.equal(PluginDirectory.prototype.PluginDirectory, true);
  });
  describe('_constructor_', function() {
    return it('Should have a _constructor_', function() {
      return assert.typeOf(PluginDirectory.prototype._constructor_, 'function');
    });
  });
  describe('#constructor', function() {
    it('creating an instance should not throw errors', function() {
      var m;

      return m = new PluginDirectory();
    });
    it('Should extends from a Logger', function() {
      return assert.equal(PluginDirectory.prototype.Logger, true);
    });
    it('Should extends from a ReadableEntity', function() {
      return assert.equal(PluginDirectory.prototype.ReadableEntity, true);
    });
    return it('Should extends from a TreeElement', function() {
      return assert.equal(PluginDirectory.prototype.TreeElement, true);
    });
  });
  describe('#readAllPlugins', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(PluginDirectory.prototype.readAllPlugins, 'function');
    });
    it('Should return an error when there is no Jelly class bound', function(cb) {
      var p;

      p = new PluginDirectory();
      return p.readAllPlugins(function(err) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    return it('Should read all plugins in the local and general plugin directory', function(cb) {
      var jelly, p;

      p = new PluginDirectory();
      jelly = new Jelly();
      p.setParent(jelly);
      jelly.setRootDirectory("" + __dirname + "/testFiles/pluginLoading");
      return p.readAllPlugins(function(err) {
        if (err != null) {
          cb(err);
          cb = function() {};
          return;
        }
        return cb();
      });
    });
  });
  describe('#readPluginDirectory', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(PluginDirectory.prototype.readPluginDirectory, 'function');
    });
    it('Should raise an error when a null value is passed as a directory', function(cb) {
      return new PluginDirectory().readPluginDirectory(null, function(err) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    it('Should read a valid plugin directory', function(cb) {
      return new PluginDirectory().readPluginDirectory("" + __dirname + "/testFiles/pluginLoading/plugins", function(err) {
        var e;

        try {
          assert.equal(err, null);
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    it('Should raise an error if the directory specified do not exist', function(cb) {
      return new PluginDirectory().readPluginDirectory("/do/not/exist", function(err) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    return it('Should raise an error if the directory specified is a file', function(cb) {
      return new PluginDirectory().readPluginDirectory("" + __dirname + "/testFiles/dummyFile.json", function(err) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
  });
  describe('#readPluginFromPath', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(PluginDirectory.prototype.readPluginFromPath, 'function');
    });
    it('Should raise an error when there null is given as a directory', function(cb) {
      var p;

      p = new PluginDirectory();
      return p.readPluginFromPath(null, "pluginName", function(err) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    it('Should raise an error when there null is given as a name', function(cb) {
      return new PluginDirectory().readPluginFromPath("" + __dirname + "/testFiles/pluginLoading/plugins/testPlugin", null, function(err, pluginHandler) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          assert.equal(pluginHandler, null);
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    return it('Should load a plugin', function(cb) {
      return new PluginDirectory().readPluginFromPath("" + __dirname + "/testFiles/pluginLoading/plugins/testPlugin", "testPlugin", function(err, pluginHandler) {
        var e;

        try {
          assert.typeOf(pluginHandler, 'object');
          assert.equal(pluginHandler.PluginHandler, true);
        } catch (_error) {
          e = _error;
          cb(e);
          cb = function() {};
          return;
        }
        return cb(err);
      });
    });
  });
  describe('#applyPluginToJelly', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(PluginDirectory.prototype.applyPluginToJelly, 'function');
    });
    it('Should raise an error when the recursive parameter is invalid', function(cb) {
      return new PluginDirectory().applyPluginToJelly(null, function(err) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          cb();
          return cb = function() {};
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    it('Should raise an error when the recursive parameter is invalid', function(cb) {
      return new PluginDirectory().applyPluginToJelly(null, function(err) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          cb();
          return cb = function() {};
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    return it('Should raise an error when the recursive parameter is invalid', function(cb) {
      var jelly, p;

      p = new PluginDirectory();
      jelly = new Jelly();
      p.setParent(jelly);
      return p.applyPluginToJelly(function(err) {
        return cb();
      });
    });
  });
  return describe('#getPluginListFromIdList', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(PluginDirectory.prototype.getPluginListFromIdList, 'function');
    });
    it('Should raise an error if the idList is not ad array', function(cb) {
      return new PluginDirectory().getPluginListFromIdList('test', function(err) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    it('Should raise an error if some plugins cannot be found', function(cb) {
      var dir, handler, handler2;

      dir = new PluginDirectory();
      handler = new PluginHandler();
      handler2 = new PluginHandler();
      handler.setId('test1');
      handler2.setId('test2');
      handler.setParent(dir);
      handler2.setParent(dir);
      dir.addChild(handler);
      dir.addChild(handler2);
      return dir.getPluginListFromIdList(['test1', 'unknown', 'test2'], function(err, list) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          assert.typeOf(list, 'array', 'it should return a list of working plugins even when there is an error');
          assert.equal(list.length, 2, 'it should return a list of working plugins even when there is an error');
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    return it('Should not raise an error if all plugins are found', function(cb) {
      var dir, handler, handler2;

      dir = new PluginDirectory();
      handler = new PluginHandler();
      handler2 = new PluginHandler();
      handler.setId('test1');
      handler2.setId('test2');
      handler.setParent(dir);
      handler2.setParent(dir);
      dir.addChild(handler);
      dir.addChild(handler2);
      return dir.getPluginListFromIdList(['test1', 'test2'], function(err, list) {
        var e;

        try {
          assert.equal(err, null);
          assert.typeOf(list, 'array', 'it should return a list of working plugins');
          assert.equal(list.length, 2, 'it should return a list of working plugins');
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
  });
});
