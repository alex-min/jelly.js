// Generated by CoffeeScript 1.6.2
var assert, async, toType;

assert = require('chai').assert;

async = require('async');

toType = function(obj) {
  return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
};

describe('ReadableEntity', function() {
  var ReadableEntity;

  ReadableEntity = require('../src/ReadableEntity');
  describe('#constructor', function() {
    return it('creating a ReadableEntity should not throw errors', function() {
      var readableEntity;

      return readableEntity = new ReadableEntity();
    });
  });
  describe('#updateAndExecuteCurrentContent', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(ReadableEntity.prototype.updateAndExecuteCurrentContent, 'function');
    });
    it('Should return an error if there is no content', function(cb) {
      var readableEntity;

      readableEntity = new ReadableEntity();
      return readableEntity.updateAndExecuteCurrentContent(function(err) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    it('Should return an error if the current content has no extension', function(cb) {
      var readableEntity;

      readableEntity = new ReadableEntity();
      readableEntity.updateContent({
        content: 'A'
      });
      return readableEntity.updateAndExecuteCurrentContent(function(err) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    it('Should return an error if the current content has an extension which does not allow execution', function(cb) {
      var readableEntity;

      readableEntity = new ReadableEntity();
      readableEntity.updateContent({
        content: 'A',
        extension: 'invalid'
      });
      return readableEntity.updateAndExecuteCurrentContent(function(err, content) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          assert.equal(content, null);
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    it('Should throw an error with an invalid json', function(cb) {
      var readableEntity;

      readableEntity = new ReadableEntity();
      readableEntity.updateContent({
        content: 'INVALID JSON',
        extension: 'json'
      });
      return readableEntity.updateAndExecuteCurrentContent(function(err, content) {
        var e;

        try {
          assert.equal(toType(err), 'error');
          assert.equal(content, null);
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    return it('Should push a content with and __exec extension if everything is valid', function(cb) {
      var readableEntity;

      readableEntity = new ReadableEntity();
      readableEntity.updateContent({
        content: '{"valid":true}',
        extension: 'json'
      });
      return readableEntity.updateAndExecuteCurrentContent(function(err, content) {
        var contentCheck, contentPushed, e;

        try {
          contentCheck = function(content) {
            assert.equal(toType(err), 'null');
            assert.equal(toType(content), 'object');
            assert.equal(content.extension, '__exec');
            assert.typeOf(content.content, 'object');
            return assert.equal(content.content.valid, true);
          };
          contentCheck(content);
          contentPushed = readableEntity.getCurrentContent();
          contentCheck(contentPushed);
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
  });
  describe('#getCurrentContent', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(new ReadableEntity().getCurrentContent, "function");
    });
    it('Should return an empty object when nothing is set', function() {
      var readableEntity;

      readableEntity = new ReadableEntity();
      return assert.equal(JSON.stringify(readableEntity.getCurrentContent()), "{}");
    });
    return it('Should get the last content pushed', function() {
      var lastContent, readableEntity;

      readableEntity = new ReadableEntity();
      assert.typeOf(readableEntity.updateContent, "function", "updateContent is not callable");
      readableEntity.updateContent({
        content: "Test1"
      });
      lastContent = readableEntity.getCurrentContent();
      assert.typeOf(lastContent, "object", "updateContent did not return a valid content");
      assert.typeOf(lastContent.content, "string", "updateContent returned the wrong content");
      assert.equal(lastContent.content, "Test1", "updateContent returned the wrong content");
      readableEntity.updateContent({
        content: "Test2"
      });
      lastContent = readableEntity.getCurrentContent();
      assert.typeOf(lastContent, "object", "updateContent did not return a valid content");
      assert.typeOf(lastContent.content, "string", "updateContent returned the wrong content");
      assert.equal(lastContent.content, "Test2", "updateContent returned the wrong content");
      readableEntity.updateContent({
        content: "Test3"
      });
      lastContent = readableEntity.getCurrentContent();
      assert.typeOf(lastContent, "object", "updateContent did not return a valid content");
      assert.typeOf(lastContent.content, "string", "updateContent returned the wrong content");
      return assert.equal(lastContent.content, "Test3", "updateContent returned the wrong content");
    });
  });
  describe('#getCurrentContentEntity', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(ReadableEntity.prototype.getCurrentContentEntity, "function");
    });
    it('Should return an null when nothing is set', function() {
      var readableEntity;

      readableEntity = new ReadableEntity();
      return assert.equal(readableEntity.getCurrentContentEntity(), null);
    });
    return it('Should get the last string content pushed', function() {
      var lastContent, readableEntity;

      readableEntity = new ReadableEntity();
      assert.typeOf(readableEntity.updateContent, "function", "updateContent is not callable");
      readableEntity.updateContent({
        content: "Test1"
      });
      lastContent = readableEntity.getCurrentContentEntity();
      assert.equal(lastContent, "Test1", "updateContent returned the wrong content");
      readableEntity.updateContent({
        content: "Test2"
      });
      lastContent = readableEntity.getCurrentContentEntity();
      assert.equal(lastContent, "Test2", "updateContent returned the wrong content");
      readableEntity.updateContent({
        content: "Test3"
      });
      lastContent = readableEntity.getCurrentContentEntity();
      return assert.equal(lastContent, "Test3", "updateContent returned the wrong content");
    });
  });
  describe('#eraseContent', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(new ReadableEntity().eraseContent, "function");
    });
    it('Should do nothing if nothing is set', function() {
      var readableEntity;

      readableEntity = new ReadableEntity();
      assert.typeOf(readableEntity.updateContent, "function", "updateContent is not callable");
      readableEntity.eraseContent();
      return assert.equal(JSON.stringify(readableEntity.getCurrentContent()), "{}");
    });
    return it('Should erase content when called', function() {
      var lastContent, readableEntity;

      readableEntity = new ReadableEntity();
      assert.typeOf(readableEntity.updateContent, "function", "updateContent is not callable");
      readableEntity.updateContent({
        content: "Test1"
      });
      readableEntity.updateContent({
        content: "Test2"
      });
      lastContent = readableEntity.getCurrentContent();
      assert.equal(lastContent.content, "Test2", "updateContent returned the wrong content");
      readableEntity.eraseContent();
      lastContent = readableEntity.getCurrentContent();
      return assert.equal(JSON.stringify(lastContent), "{}", "content is not erased");
    });
  });
  describe('#getFirstContent', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(new ReadableEntity().getFirstContent, "function");
    });
    it('Should return an empty object when nothing is set', function() {
      var readableEntity;

      readableEntity = new ReadableEntity();
      return assert.equal(JSON.stringify(readableEntity.getFirstContent()), "{}");
    });
    return it('Should get the first content pushed', function() {
      var lastContent, readableEntity;

      readableEntity = new ReadableEntity();
      assert.typeOf(readableEntity.updateContent, "function", "updateContent is not callable");
      readableEntity.updateContent({
        content: "Test1"
      });
      lastContent = readableEntity.getFirstContent();
      assert.typeOf(lastContent, "object", "updateContent did not return a valid content");
      assert.typeOf(lastContent.content, "string", "updateContent returned the wrong content");
      assert.equal(lastContent.content, "Test1", "updateContent returned the wrong content");
      readableEntity.updateContent({
        content: "Test2"
      });
      lastContent = readableEntity.getFirstContent();
      assert.typeOf(lastContent, "object", "updateContent did not return a valid content");
      assert.typeOf(lastContent.content, "string", "updateContent returned the wrong content");
      assert.equal(lastContent.content, "Test1", "updateContent returned the wrong content");
      readableEntity.updateContent({
        content: "Test3"
      });
      lastContent = readableEntity.getFirstContent();
      assert.typeOf(lastContent, "object", "updateContent did not return a valid content");
      assert.typeOf(lastContent.content, "string", "updateContent returned the wrong content");
      return assert.equal(lastContent.content, "Test1", "updateContent returned the wrong content");
    });
  });
  describe('#getContentList', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(new ReadableEntity().getContentList, "function");
    });
    it('Should return an empty array when nothing is set', function() {
      var readableEntity;

      readableEntity = new ReadableEntity();
      return assert.equal(JSON.stringify(readableEntity.getContentList()), "[]");
    });
    return it('Should get the list of content pushed', function() {
      var contentList, readableEntity;

      readableEntity = new ReadableEntity();
      assert.typeOf(readableEntity.updateContent, "function", "updateContent is not callable");
      readableEntity.updateContent({
        content: "Test1"
      });
      contentList = readableEntity.getContentList();
      assert.isArray(contentList, "getContentList() should return an array");
      assert.equal(contentList.length, 1, "The array returned is incorrect");
      assert.typeOf(contentList[0].content, "string", "returned the wrong content");
      assert.equal(contentList[0].content, "Test1", "The content of the array returned is incorrect");
      readableEntity.updateContent({
        content: "Test2"
      });
      contentList = readableEntity.getContentList();
      assert.isArray(contentList, "getContentList() should return an array");
      assert.equal(contentList.length, 2, "The array returned is incorrect");
      assert.typeOf(contentList[0].content, "string", "returned the wrong content");
      assert.equal(contentList[0].content, "Test1", "The content of the array returned is incorrect");
      assert.typeOf(contentList[1].content, "string", "returned the wrong content");
      assert.equal(contentList[1].content, "Test2", "The content of the array returned is incorrect");
      readableEntity.updateContent({
        content: "Test3"
      });
      contentList = readableEntity.getContentList();
      assert.isArray(contentList, "getContentList() should return an array");
      assert.equal(contentList.length, 3, "The array returned is incorrect");
      assert.typeOf(contentList[0].content, "string", "returned the wrong content");
      assert.equal(contentList[0].content, "Test1", "The content of the array returned is incorrect");
      assert.typeOf(contentList[1].content, "string", "returned the wrong content");
      assert.equal(contentList[1].content, "Test2", "The content of the array returned is incorrect");
      assert.typeOf(contentList[2].content, "string", "returned the wrong content");
      return assert.equal(contentList[2].content, "Test3", "The content of the array returned is incorrect");
    });
  });
  describe('#updateContent', function() {
    return it('Should be a callable function', function() {
      return assert.typeOf(new ReadableEntity().updateContent, "function");
    });
  });
  describe('#getLastContentOfExtension', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(new ReadableEntity().getLastContentOfExtension, "function");
    });
    it('Should return null when there is no content available matching the extension', function() {
      return assert.equal(new ReadableEntity().getLastContentOfExtension('ff'), null);
    });
    it('Should return the last content available matching the extension', function() {
      var content, readableEntity;

      readableEntity = new ReadableEntity();
      readableEntity.updateContent({
        content: 'A',
        extension: 'txt'
      });
      readableEntity.updateContent({
        content: 'B',
        extension: 'txt'
      });
      content = readableEntity.getLastContentOfExtension('txt');
      assert.typeOf(content, 'object', 'the function should return an object');
      return assert.equal(content.content, 'B', 'the function returned the wrong content');
    });
    return it('Should return null when the extension is null', function() {
      var content, readableEntity;

      readableEntity = new ReadableEntity();
      readableEntity.updateContent({
        content: 'A',
        extension: 'txt'
      });
      content = readableEntity.getLastContentOfExtension(null);
      return assert.equal(content, null);
    });
  });
  describe('#getLastExecutableContent', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(new ReadableEntity().getLastExecutableContent, "function");
    });
    return it('Should return the last executable content', function() {
      var content, readableEntity;

      readableEntity = new ReadableEntity();
      readableEntity.updateContent({
        content: 'A',
        extension: 'txt'
      });
      readableEntity.updateContent({
        content: 'B',
        extension: '__exec'
      });
      readableEntity.updateContent({
        content: 'C',
        extension: '__exec'
      });
      readableEntity.updateContent({
        content: 'D',
        extension: 'txt'
      });
      content = readableEntity.getLastExecutableContent();
      assert.typeOf(content, 'string', 'the function should return the content pushed');
      return assert.equal(content, 'C', 'the function should return the content pushed');
    });
  });
  describe('ReadableEntity', function() {
    return it('Should be an instance of ReadableEntity', function() {
      return assert.equal(new ReadableEntity().ReadableEntity, true);
    });
  });
  return describe('#updateContentFromFile', function() {
    it('Should be a callable function', function() {
      return assert.typeOf(new ReadableEntity().updateContentFromFile, "function");
    });
    it('Should gather the content from a file', function(cb) {
      var readableEntity;

      readableEntity = new ReadableEntity();
      return readableEntity.updateContentFromFile("" + __dirname + "/testFiles/dummyFile.txt", function(err, dt) {
        var e;

        try {
          assert.equal(err, null, "updateContentFromFile throws an error");
          assert.equal(dt.content, "DUMMYCONTENT", "the content of the file read is invalid");
          assert.typeOf(dt.filename, "string");
          assert.typeOf(dt.content, "string");
          assert.equal(dt.extension, "txt");
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    it('Should return an error when the file cannot be read', function(cb) {
      var readableEntity;

      readableEntity = new ReadableEntity();
      return readableEntity.updateContentFromFile("This/file/do/not/exist", function(err, dt) {
        var e;

        try {
          assert.equal(toType(err), "error", "the function returned an invalid error");
          assert.equal(dt, null, "the function should return null");
          return cb();
        } catch (_error) {
          e = _error;
          return cb(e);
        }
      });
    });
    return it('Should call updateContent', function(cb) {
      var e, readableEntity;

      try {
        readableEntity = new ReadableEntity();
        readableEntity.updateContent({
          content: 'A'
        });
        return readableEntity.updateContentFromFile("" + __dirname + "/testFiles/dummyFile.txt", function(err, dt) {
          var e;

          try {
            assert.equal("" + (readableEntity.getCurrentContent().content), "DUMMYCONTENT", "the content was not updated");
            return cb();
          } catch (_error) {
            e = _error;
            return cb(e);
          }
        });
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    });
  });
});
