// Generated by CoffeeScript 1.6.2
var File, Logger, PluginInterface, ReadableEntity, Tools, TreeElement, async, fs, _PluginInterface;

async = require('async');

fs = require('fs');

Tools = require('./Tools');

Logger = require('./Logger');

ReadableEntity = require('./ReadableEntity');

TreeElement = require('./TreeElement');

File = require('./File');

/**
 * PluginInterface is the child class of PluginHandler.
 * Each PluginHandler instance is suppose to contain a PluginInterface class.
 * This class is dealing directly with the plugin code.
 * 
 * @class PluginInterface
 * @extends Logger
 * @extends ReadableEntity
 * @extends TreeElement
*/


PluginInterface = Tools.implementing(Logger, ReadableEntity, TreeElement, _PluginInterface = (function() {
  function _PluginInterface() {}

  return _PluginInterface;

})(), PluginInterface = (function() {
  function PluginInterface() {
    this._constructor_();
  }

  PluginInterface.prototype._constructor_ = function() {
    this._parentConstructor_();
    return this._status = PluginInterface.prototype.STATUS.NOT_LOADED;
  };

  /**
   *  @property {Object} STATUS
   *  @c
   *  @attribute {Int} NOT_LOADED The plugin is not loaded
   *  @attribute {Int} LOADED The plugin is loaded
  */


  PluginInterface.prototype.STATUS = {
    NOT_LOADED: 0,
    LOADED: 1
  };

  /**
   * Get the {SharedObjectManager} instance associated with the Jelly parent class.
   *
   * @for PluginInterface
   * @method getSharedObjectManager
   * @return {SharedObjectManager} The SharedObjectManager
  */


  PluginInterface.prototype.getSharedObjectManager = function() {
    var jelly;

    jelly = this.getParentOfClass('Jelly');
    if (jelly === null) {
      return null;
    }
    return jelly.getSharedObjectManager();
  };

  /**
   * Get the {SharedObjectManager} instance associated with the Jelly parent class.
   *
   * @for PluginWrapper
   * @method getSharedObjectManager
   * @return {SharedObjectManager} The SharedObjectManager
  */


  PluginInterface.prototype.getSharedObjectManager = function() {
    var jelly;

    jelly = this.getParentOfClass('Jelly');
    if (jelly === null) {
      return null;
    }
    return jelly.getSharedObjectManager();
  };

  /**
   * Get the current status of the plugin.
   * Currently, two values are possible : <ul>
   *  <li><strong> PluginInterface::STATUS.NOT_LOADED </strong> : The plugin is currently not loaded.</li>
   *  <li><strong> PluginInterface::STATUS.LOADED </strong> : The plugin is loaded </li></ul>
   *
   * @for PluginInterface
   * @method getStatus
   * @return {PluginInterface::STATUS} Current status of the plugin
  */


  PluginInterface.prototype.getStatus = function() {
    return this._status;
  };

  /**
   * Set the current status of the plugin.
   * Currently, two values are possible : <ul>
   *  <li><strong> PluginInterface::STATUS.NOT_LOADED </strong> : The plugin is currently not loaded.</li>
   *  <li><strong> PluginInterface::STATUS.LOADED </strong> : The plugin is loaded </li></ul>
   *
   * @for PluginInterface
   * @method setStatus
   * @param {PluginInterface::STATUS} New status of the plugin
   * @return {PluginInterface::STATUS} New status of the plugin (or null if the status is invalid)
  */


  PluginInterface.prototype.setStatus = function(status) {
    if (status === PluginInterface.prototype.STATUS.NOT_LOADED || status === PluginInterface.prototype.STATUS.LOADED) {
      this._status = status;
    }
    return null;
  };

  /**
   * This method will trigger exports.unload on the main plugin file.
   * This method must be called when reloading the plugin to let the plugin know a reload event is happening.
   *
   * @for PluginInterface
   * @method unload
   * @async
   * @param {Function}[callback] callback function
   * @param {Error} callback.err Error found during execution
  */


  PluginInterface.prototype.unload = function(cb) {
    var content, self;

    cb = cb || function() {};
    self = this;
    content = this.getLastExecutableContent();
    if (content === null) {
      this.getLogger().warn('Unable to unload plugin : There is no content');
      cb(null);
      cb = function() {};
      return;
    }
    if (typeof content !== 'object') {
      this.getLogger().warn('Unable to unload plugin : The content is not an object');
      cb(null);
      cb = function() {};
      return;
    }
    if (typeof content.unload !== 'function') {
      this.getLogger().warn('Unable to unload plugin: There is no unload function exported in the plugin file');
      cb(null);
      cb = function() {};
      return;
    }
    if (this.getStatus() === PluginInterface.prototype.STATUS.NOT_LOADED) {
      cb();
      return;
    }
    return content.unload.call(this, function() {
      self.setStatus(PluginInterface.prototype.STATUS.NOT_LOADED);
      return cb();
    });
  };

  /**
   * This method will trigger exports.load on the main plugin file.
   * This method must be called when reloading the plugin to let the plugin know a reload event is happening.
   *
   * @for PluginInterface
   * @method load
   * @async
   * @param {Function}[callback] callback function
   * @param {Error} callback.err Error found during execution
  */


  PluginInterface.prototype.load = function(cb) {
    var content, self;

    cb = cb || function() {};
    self = this;
    content = this.getLastExecutableContent();
    if (content === null) {
      this.getLogger().warn('Unable to load plugin : There is no content');
      cb(null);
      cb = function() {};
      return;
    }
    if (typeof content !== 'object') {
      this.getLogger().warn('Unable to load plugin : The content is not an object');
      cb(null);
      cb = function() {};
      return;
    }
    if (typeof content.load !== 'function') {
      this.getLogger().warn('Unable to load plugin: There is no load function exported in the plugin file');
      cb(null);
      cb = function() {};
      return;
    }
    if (this.getStatus() === PluginInterface.prototype.STATUS.LOADED) {
      cb();
      return;
    }
    return content.load.call(this, function() {
      self.setStatus(PluginInterface.prototype.STATUS.LOADED);
      return cb();
    });
  };

  /**
   * This method is the equivalent of calling unload and load just after.
   * This will trigger exports.unload and export.load on the plugin main file.
   *
   * @for PluginInterface
   * @method reload
   * @async
   * @param {Function}[callback] callback function
   * @param {Error} callback.err Error found during execution
  */


  PluginInterface.prototype.reload = function(cb) {
    var self;

    cb = cb || function() {};
    self = this;
    return async.series([
      function(cb) {
        return self.unload(cb);
      }, function(cb) {
        return self.load(cb);
      }
    ], function(err) {
      return cb(err);
    });
  };

  /**
   * This method will trigger exports.oncall on the main plugin file.
   *
   * @for PluginInterface
   * @method oncall
   * @async
   * @param {Object} senderClass The sender class which the plugin should apply.
   * @param {Object} params Plugins parameters found in the configuration file
   * @param {Function}[callback] callback function
   * @param {Error} callback.err Error found during execution
  */


  PluginInterface.prototype.oncall = function(senderClass, params, cb) {
    var content, self;

    cb = cb || function() {};
    self = this;
    content = this.getLastExecutableContent();
    if (content === null) {
      cb(new Error('Unable to oncall plugin : There is no content'));
      cb = function() {};
      return;
    }
    if (typeof content !== 'object') {
      cb(new Error('Unable to oncall plugin : The content is not an object'));
      cb = function() {};
      return;
    }
    if (this.getParent() === null) {
      cb(new Error('Unable to oncall plugin : There is no PluginHandler parent on the plugin'));
      cb = function() {};
      return;
    }
    if (Object.getPrototypeOf(this.getParent()).TreeElement !== true) {
      cb(new Error('The PluginInterface must extend from a TreeElement'));
      cb = function() {};
      return;
    }
    if (typeof content.oncall !== 'function') {
      cb(new Error("Unable to oncall plugin '" + (this.getParent().getId()) + "': There is no oncall function exported in the plugin file"));
      cb = function() {};
      return;
    }
    if (senderClass === null || typeof senderClass === 'undefined') {
      cb(new Error('The senderClass to bind the oncall method is invalid (null)'));
      cb = function() {};
      return;
    }
    return content.oncall.call(this, senderClass, params, function(err) {
      self.setStatus(PluginInterface.prototype.STATUS.LOADED);
      return cb(err);
    });
  };

  return PluginInterface;

})());

module.exports = PluginInterface;
