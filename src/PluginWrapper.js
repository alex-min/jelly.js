// Generated by CoffeeScript 1.6.2
var File, Logger, PluginHandler, PluginWrapper, ReadableEntity, Tools, TreeElement, async, fs;

async = require('async');

fs = require('fs');

Tools = require('./Tools');

Logger = require('./Logger');

ReadableEntity = require('./ReadableEntity');

TreeElement = require('./TreeElement');

File = require('./File');

PluginHandler = require('./PluginHandler');

/**
 * PluginWrapper is a class providing plugin capabilities to another class.
 * Jelly, GeneralConfiguration, Module and File are inheriting from it. 
 * 
 * @class PluginWrapper
*/


PluginWrapper = (function() {
  PluginWrapper.prototype.PluginWrapper = true;

  PluginWrapper.prototype._constructor_ = function() {};

  function PluginWrapper() {
    this._constructor_();
  }

  PluginWrapper.prototype._applyPluginFile = function(pluginHandler, cb) {
    var config, module, _base, _name, _ref, _ref1;

    module = this.getParent();
    if (module === null || typeof module === 'undefined') {
      cb(new Error("The specified File '" + (this.getId()) + "' does not have a parent module"));
      cb = function() {};
      return;
    }
    config = module.getLastExecutableContent();
    if (config === null) {
      cb(new Error("There is no config file read on the parent module of the File '" + (this.getId()) + "'"));
      cb = function() {};
      return;
    }
    if ((_ref = config.filePluginParameters) == null) {
      config.filePluginParameters = {};
    }
    if ((_ref1 = (_base = config.filePluginParameters)[_name = pluginHandler.getId()]) == null) {
      _base[_name] = {};
    }
    return pluginHandler.getPluginInterface().oncall(this, {
      plugins: config.plugins,
      pluginParameters: config.filePluginParameters
    }, cb);
  };

  PluginWrapper.prototype._applyPluginOtherClass = function(pluginHandler, cb) {
    var config, e, self, _base, _name, _ref, _ref1;

    self = this;
    config = self.getLastExecutableContent();
    if (config === null) {
      cb(new Error("There is no config file loaded for the Id '" + (self.getId()) + "' on a " + self.constructor.name + " object"));
      cb = function() {};
      return;
    }
    if ((_ref = config.pluginParameters) == null) {
      config.pluginParameters = {};
    }
    if ((_ref1 = (_base = config.pluginParameters)[_name = pluginHandler.getId()]) == null) {
      _base[_name] = {};
    }
    try {
      return pluginHandler.getPluginInterface().oncall(self, config, cb);
    } catch (_error) {
      e = _error;
      return cb(e);
    }
  };

  /**
   * Find and apply all the plugins defined in the cofiguration file.
   *
   * @for PluginWrapper
   * @method applyPluginsSpecified
   * @aync
   * @param {Boolean} [recursive] Applying plugins on all childs (Default : false).
   * @param {Function}[callback] callback function
   * @param {Error} callback.err Error found during execution
  */


  PluginWrapper.prototype.applyPluginsSpecified = function(recursive, cb) {
    var jelly, pluginDirectory, self;

    cb = cb || function() {};
    self = this;
    if (typeof recursive === 'function') {
      cb = recursive;
      recursive = false;
    }
    if (typeof recursive !== 'boolean') {
      cb(new Error("Invalid non-boolean parameter passed as 'recursive' : " + recursive));
      cb = function() {};
      return;
    }
    if (Object.getPrototypeOf(this).TreeElement !== true) {
      cb(new Error('The object must inherit from a TreeElement to use PluginWrapper::applyPluginsSpecified'));
      cb = function() {};
      return;
    }
    jelly = this.getParentOfClass('Jelly');
    if (jelly === null) {
      cb(new Error("There is no Jelly parent on Id '" + (this.getId()) + "'."));
      cb = function() {};
      return;
    }
    pluginDirectory = jelly.getPluginDirectoryList();
    if (pluginDirectory === null || typeof pluginDirectory === 'undefined') {
      cb(new Error('There is no pluginDirectory instance bound to the Jelly instance'));
      cb = function() {};
      return;
    }
    return async.waterfall([
      function(cb) {
        return self.getPluginList(cb);
      }, function(list, cb) {
        return pluginDirectory.getPluginListFromIdList(list, cb);
      }, function(plugins, cb) {
        return async.map(plugins, function(plugin, cb) {
          return self.applyPlugin(plugin, cb);
        }, function(err) {
          return cb(err);
        });
      }
    ], function(err) {
      if (err != null) {
        cb(err);
        cb = function() {};
        return;
      }
      if (recursive) {
        return async.map(self.getChildList(), function(child, cb) {
          return child.applyPluginsSpecified(true, cb);
        }, function(err) {
          cb(err);
          return cb = function() {};
        });
      } else {
        cb();
        return cb = function() {};
      }
    });
  };

  /**
   * Apply a plugin to the current class (this). Only for class which extends from a PluginWrapper.
   *
   * @for PluginWrapper
   * @method applyPlugin
   * @aync
   * @param {PluginHandler} The plugin to apply to the class
   * @param {String} filename The location of the file
   * @param {Function}[callback] callback function
   * @param {Error} callback.err Error found during execution
  */


  PluginWrapper.prototype.applyPlugin = function(pluginHandler, cb) {
    var self;

    cb = cb || function() {};
    self = this;
    if (typeof pluginHandler === 'undefined' || pluginHandler === null || pluginHandler.PluginHandler !== true) {
      cb(new Error("Unable to apply plugin : Invalid pluginHandler passed as a parameter"));
      cb = function() {};
      return;
    }
    if (self.ReadableEntity !== true) {
      cb(new Error("Unable to apply plugin : The class must inherit from ReadableEntity to use this method"));
      return;
    }
    if (pluginHandler.getId() === null) {
      cb(new Error("The pluginHandler must have an ID to be applied."));
      cb = function() {};
      return;
    }
    if (self.File === true) {
      return this._applyPluginFile(pluginHandler, cb);
    } else {
      return this._applyPluginOtherClass(pluginHandler, cb);
    }
  };

  /**
   * Get the list of plugins to apply to a particular class.
   * This method will read the entry 'plugins' on the last executable content of the class.
   * For a File instance, the parent module will be used instead.
   * This method does not load anything.
   *
   * @for PluginWrapper
   * @method getPluginList
   * @aync
   * @param {Function}[callback] callback function
   * @param {Error} callback.err Error found during execution
   * @param {String[]} callback.pluginList The plugin list (as an array of string)
  */


  PluginWrapper.prototype.getPluginList = function(cb) {
    var content, e, errormsg, object, parent;

    cb = cb || function() {};
    object = this;
    errormsg = 'Unable to get the plugin list';
    try {
      if (typeof Object.getPrototypeOf(object).TreeElement === 'undefined') {
        cb(new Error("" + errormsg + ": The object must extend from a TreeElement"), null);
        return;
      }
      if (Object.getPrototypeOf(object).ReadableEntity !== true) {
        cb(new Error("" + errormsg + ": The object must extend from a ReadableEntity"), null);
        cb = function() {};
        return;
      }
      content = object.getLastExecutableContent();
      if (content === null && typeof object.File === 'undefined') {
        cb(new Error("" + errormsg + " on " + (object.getId()) + ": There is no content loaded"), null);
        cb = function() {};
        return;
      }
      if (typeof Object.getPrototypeOf(object).File !== 'undefined') {
        parent = object.getParent();
        if (parent === null) {
          cb(new Error("" + errormsg + " on File '" + (object.getId()) + "', There is no parent module bound to the class"), null);
          cb = function() {};
          return;
        }
        content = parent.getLastExecutableContent();
        if (content === null) {
          cb(new Error("" + errormsg + " on File '" + (object.getId()) + "', There is no content on the parent module."), null);
          cb = function() {};
          return;
        }
        cb(null, content.filePlugins || []);
        return cb = function() {};
      } else {
        cb(null, content.plugins || []);
        return cb = function() {};
      }
    } catch (_error) {
      e = _error;
      cb(e);
      return cb = function() {};
    }
  };

  return PluginWrapper;

})();

module.exports = PluginWrapper;
