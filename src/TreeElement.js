// Generated by CoffeeScript 1.6.2
/**
 * TreeElement is a class for dealing with the architecture of the web framework.
 * It helps to handle the hierarchy of [Jelly] -> [GeneralConfiguration] -> [Module] -> [File] 
 * 
 * @class TreeElement
*/

var TreeElement;

TreeElement = (function() {
  TreeElement.prototype.TreeElement = true;

  function TreeElement() {
    this._constructor_();
  }

  TreeElement.prototype._constructor_ = function() {
    this._childList = [];
    this._parent = null;
    return this._id = null;
  };

  /**
   * This method will return set the Id returned by the method TreeElement::getId
   * The main goal is to provide an easy system to find node in TreeElements
   * The default id is set to null.
   * Any call to setId will replace the previous id without further check.
   *
   * @for TreeElement
   * @method setId
   * @param {Any Type} Id of the element (or null)
  */


  TreeElement.prototype.setId = function(_id) {
    return this._id = _id;
  };

  /**
   * This method will return the Id set by the method TreeElement::setId
   * The main goal is to provide an easy system to find node in TreeElements
   * The default id is set to null.
   *
   * @for TreeElement
   * @method getId
   * @return {Any Type} Id of the element (or null)
  */


  TreeElement.prototype.getId = function() {
    return this._id;
  };

  /**
   * This method will find a child by its Id.
   * If nothing is found, the method will return null.
   * Any null id passed to the method will result in a null return without any further research.
   *
   * @for TreeElement
   * @method getChildById
   * @param {Any Type} Searched id
   * @param {TreeElement} Child found by the id (or null)
  */


  TreeElement.prototype.getChildById = function(id) {
    var child, _i, _len, _ref;

    if (typeof id === 'undefined' || id === null) {
      return null;
    }
    _ref = this._childList;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.getId() === id) {
        return child;
      }
    }
    return null;
  };

  /**
   * This method will find a child by its Id in a recursive way.<br>
   * If nothing is found, the method will return null.<br>
   * Any null id passed to the method will result in a null return without any further research.<br>
   * This method (unlike getChildById) can also return <code>this</code> if the ID is matching.
   *
   * @for TreeElement
   * @method getChildByIdRec
   * @param {Any Type} Searched id
   * @param {TreeElement} Child found by the id (or null)
  */


  TreeElement.prototype.getChildByIdRec = function(id) {
    var c, child, _i, _len, _ref;

    if (typeof id === 'undefined' || id === null) {
      return null;
    }
    if (this.getId() === id && this.getId() !== null) {
      return this;
    }
    _ref = this._childList;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.getId() === id) {
        return child;
      } else {
        c = child.getChildByIdRec(id);
        if (c !== null) {
          return c;
        }
      }
    }
    return null;
  };

  /**
   * Get the list of children (the list should consist of TreeElement classes).
   * This function should return an empty array when nothing is set.
   *
   * @for TreeElement
   * @method getChildList
   * @return {TreeElement[]} Array of TreeElements
  */


  TreeElement.prototype.getChildList = function() {
    return this._childList;
  };

  /**
   * Get the parent of the element (there is only one parent per TreeElement)
   * This function should return null when nothing is set.
   *
   * @for TreeElement
   * @method getParent
   * @return {TreeElement} Parent element
  */


  TreeElement.prototype.getParent = function() {
    return this._parent;
  };

  TreeElement.prototype.getParentOfClass = function(className) {
    var currentObj;

    if (typeof className !== 'string') {
      return null;
    }
    currentObj = this;
    while (1) {
      if (currentObj === null || Object.getPrototypeOf(currentObj)[className] === true) {
        return currentObj;
      }
      currentObj = currentObj.getParent();
    }
  };

  TreeElement.prototype.getParentOfLevel = function(level) {
    var currentObj, i, parent;

    if (typeof level !== 'number') {
      return null;
    }
    if (level === 0) {
      return this;
    }
    i = 1;
    currentObj = this;
    parent = null;
    while (i < level) {
      parent = currentObj.getParent();
      if (parent === null) {
        return null;
      }
      i++;
    }
    return parent;
  };

  /**
   * Set the parent of the element (there is only one parent per TreeElement)
   * This function should return null in its callback when everything is ok.
   * The parent element must inherits from a TreeElement, this will be checked in the function.
   * In the case of an invalid element, an error will be returned in the callback.
   * The error will be a Javacript native Error.
   * Any existing parent will be replaced when calling this method.
   *
   * @for TreeElement
   * @method setParent
   * @param {TreeElement} New parent of the element
   * @param {Function} callback. Params returned : (err : Errors when setting the new parent).
  */


  TreeElement.prototype.setParent = function(parent, cb) {
    cb = cb || function() {};
    if (typeof parent !== 'object' || Object.getPrototypeOf(parent).TreeElement !== true) {
      return cb(new Error("The parent class must inherits from a TreeElement"));
    } else {
      this._parent = parent;
      return cb(null);
    }
  };

  /**
   * Add a new child to the child list
   * The parent element must inherits from a TreeElement, this will be checked in the function.
   * In the case of an invalid element, an error will be returned in the callback.
   * The error will be a Javacript native Error.
   * If the child is already in the list, only one instance will be added.
   *
   * @for TreeElement
   * @method addChild
   * @param {TreeElement} Element to add to the child list.
   * @param {Function}[callback]. Callback function
   * @param {Error}. Errors found when executing the method (or null)
   * @param {TreeElement}. The TreeElement sent before on the callback.
   * In the case of an error, null will be returned.
  */


  TreeElement.prototype.addChild = function(child, cb) {
    var err;

    if (typeof child !== 'object' || Object.getPrototypeOf(child).TreeElement !== true) {
      err = new Error("The child class must inherits from a TreeElement");
      if (cb != null) {
        return cb(err, null);
      } else {
        throw err;
      }
    } else {
      cb = cb || function() {};
      if (this.getChildById(child.getId()) !== null) {
        cb(null, child);
        cb = function() {};
        return;
      }
      this._childList.push(child);
      child.setParent(this);
      cb(null, child);
    }
  };

  return TreeElement;

})();

module.exports = TreeElement;
