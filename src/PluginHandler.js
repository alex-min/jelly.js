// Generated by CoffeeScript 1.6.2
var File, Logger, PluginHandler, PluginInterface, ReadableEntity, Tools, TreeElement, async, fs, _PluginHandler;

async = require('async');

fs = require('fs');

Tools = require('./Tools');

Logger = require('./Logger');

ReadableEntity = require('./ReadableEntity');

TreeElement = require('./TreeElement');

File = require('./File');

PluginInterface = require('./PluginInterface');

/**
 * PluginHandler is the child class of PluginDirectory.
 * Each PluginDirectory instance is suppose to contain a PluginHandler class with itself, multiple PluginInterface in it.
 * This class is dealing with configuration related to a plugin.
 * The code is handled by a PluginInterface class
 * 
 * @class PluginHandler
 * @extends Logger
 * @extends ReadableEntity
 * @extends TreeElement
*/


PluginHandler = Tools.implementing(Logger, ReadableEntity, TreeElement, _PluginHandler = (function() {
  function _PluginHandler() {}

  return _PluginHandler;

})(), PluginHandler = (function() {
  function PluginHandler() {
    this._constructor_();
  }

  PluginHandler.prototype._constructor_ = function() {
    this._parentConstructor_();
    this._pluginInterface = new PluginInterface();
    this._pluginInterface.setParent(this);
    return this.addChild(this._pluginInterface);
  };

  PluginHandler.prototype._setDefaultContent = function(content) {
    var _ref;

    if ((_ref = content.mainFile) == null) {
      content.mainFile = 'main.js';
    }
    return content;
  };

  /**
   * Read config file of the plugin (/config.json).
   * This method will update the current content to the config file.
   * Before calling this function, make sure a directory is previously pushed as a content (by calling updateContent).
   * To set a new directory for the plugin, please call this.updateContent({directory:'newdir'}).
   * This method must be called again after to update the configuration file.
   *
   * @for PluginHandler
   * @method readConfigFile
   * @async
   * @param {Function}[callback] callback function
   * @param {String} callback.err Error found during execution
  */


  PluginHandler.prototype.readConfigFile = function(cb) {
    var dir, e, self;

    self = this;
    cb = cb || function() {};
    try {
      dir = this.getLastDirectory();
      if (dir === null) {
        cb(new Error('No directory is specified'));
        cb = function() {};
        return;
      }
      return this.readUpdateAndExecute("" + dir + "/config.json", 'utf8', function(err, data) {
        if (err != null) {
          cb(new Error("Unable to read the plugin configuration file : " + err.message));
          cb = function() {};
          return;
        }
        self._setDefaultContent(self.getLastExecutableContent());
        self.readMainEntryFile(cb);
        return cb = function() {};
      });
    } catch (_error) {
      e = _error;
      return cb(e);
    }
  };

  /**
   * Read the main entry point of the plugin (default:main.js).
   * The name of the main entry file can be set from the plugin config.json with the entry 'mainFile'.
   * You must have set a directory ( updateContent({directory:'/dir/to/set'}) ) before using this method.  
   *
   * @for PluginHandler
   * @method readMainEntryFile
   * @async
   * @param {Function}[callback] callback function
   * @param {Error} callback.err Error found during execution
  */


  PluginHandler.prototype.readMainEntryFile = function(cb) {
    var content, dir, e, plugin, self;

    cb = cb || function() {};
    self = this;
    dir = this.getLastDirectory();
    if (dir === null) {
      cb(new Error('No directory is specified'), null);
      cb = function() {};
      return;
    }
    content = this.getLastExecutableContent();
    if (content === null) {
      cb(new Error('The configuration file is not loaded (please call PluginHandler::readConfigFile before using this method)'), null);
      cb = function() {};
      return;
    }
    this._setDefaultContent(content);
    try {
      plugin = require("" + dir + "/" + content.mainFile);
      this._pluginInterface.updateContent({
        extension: '__exec',
        content: plugin
      });
      return cb();
    } catch (_error) {
      e = _error;
      return cb(e);
    }
  };

  /**
   * Get the PluginInterface instance associated with the class.
   * The PluginInterface instance is handling the main file (default:main.js) of the plugin.
   * The instance is created in the constructor, there is no need to call anything to create it.
   *
   * @for PluginHandler
   * @method getPluginInterface
   * @return {PluginInterface} The PluginInterface instance
  */


  PluginHandler.prototype.getPluginInterface = function() {
    return this._pluginInterface;
  };

  /**
   * Reload the plugin.
   * Will call in the order : <ul>
   *  <li> <strong>readConfigFile</strong> :
   *    Read the config.json from the plugin</li>
   *  <li> <strong>readMainEntryFile</strong> :
   *    Read the main.js (or what is specified on the config.json file (mainFile entry)</li>
   *  <li> <strong>getPluginInterface().reload()</strong> :
   *    reload the current plugin.
   * </ul>
   * You must have set a directory ( updateContent({directory:'/dir/to/set'}) ) before using this method.  
   *
   * @for PluginHandler
   * @method reload
   * @async
   * @param {Function}[callback] callback function
   * @param {Error} callback.err Error found during execution
  */


  PluginHandler.prototype.reload = function(cb) {
    var self;

    cb = cb || function() {};
    self = this;
    return this.readConfigFile(function(err) {
      var content;

      if (err != null) {
        cb(err);
        cb = function() {};
        return;
      }
      content = self.getLastExecutableContent();
      self._setDefaultContent(content);
      return async.series([
        function(cb) {
          return self.readMainEntryFile(cb);
        }, function(cb) {
          return self._pluginInterface.reload(cb);
        }
      ], function(err) {
        return cb(err);
      });
    });
  };

  return PluginHandler;

})());

module.exports = PluginHandler;
